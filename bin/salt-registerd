#!/usr/bin/env python
# Copyright (c) 2014 SUSE
#
# Licensed under the MIT license. See MIT-LICENSE for details.
#

"""
This is a standlone program and not meant to be imported.
"""

import logging
import re
import sys
import json
from contextlib import contextmanager

import salt.utils.event
import salt.client

from spacewalk.common import rhnFlags
from spacewalk.server import rhnUser, rhnServer, rhnSQL
from spacewalk.server import rhnAction
from spacewalk.common.rhnConfig import initCFG
from spacewalk.common.rhnException import rhnFault
# TODO: is this needed?
from rhn import rpclib

logger = logging.getLogger("spacewalk.salt-reactor")
logger.addHandler(logging.StreamHandler())

# TODO: Where does this fit in?
SALT_JOB_ACTION_TYPE_ID = 503

# TODO: is this needed?
XMLRPC_URL = "http://localhost/XMLRPC"


@contextmanager
def transaction(context=None):
    """
    TODO: doc
    """
    try:
        yield
        rhnSQL.commit()
    except rhnFault as error:
        if context is not None:
            logger.exception("%s: %s", error, context)
        else:
            logger.exception("Rolling back rhnSQL transaction: %s", error)
        rhnSQL.rollback()


def register_system(client, data):
    """
    TODO: doc
    """
    minion = data['data']['id']

    # ask for the minion data to get its id that tell us
    # if it is registered, and data to register it
    ret = client.cmd_iter(minion, 'grains.items')

    for grains in ret:
        logger.debug(grains)

        if minion in grains:
            values = grains[minion]['ret']

            # FIXME: cheat
            user = rhnUser.search('admin')

            rhnSQL.clear_log_id()
            newserv = rhnServer.Server(user, values['osarch'])

            # Idea. In the future, search for the reg key using
            # pillars. Then if no key is found for a system
            # use
            # tokens_obj = rhnServer.search_org_token(user.contact["org_id"])
            # rhnFlags.set("universal_registration_token", tokens_obj)
            #
            # FIXME: Hackweek hardcoded!
            tokens_obj = rhnServer.search_token('1-SALT')

            # log_user_id = tokens_obj.get_user_id()
            rhnFlags.set("registration_token", tokens_obj)

            # Use a generated spacewalk id for now
            # newserv.server.data['id'] = (234234234, 0)
            # reserve the id
            newserv.getid()
            # overrite the digital id
            newserv.server['digital_server_id'] = 'SALT-ID-%s' % minion
            newserv.server['release'] = values['osrelease']
            newserv.server['os'] = values['osfullname']
            newserv.server['name'] = minion
            newserv.server['running_kernel'] = values['kernelrelease']
            newserv.virt_uuid = None
            newserv.save()

            rhnSQL.commit()

            logger.info("%s registered as %s", minion, newserv.getid())
        else:
            logger.warning("Can't get grains for %s", minion)


def is_minion_registered(minion):
    """
    Returns sid if a minion is registered, False otherwise
    """
    result = False
    cursor = rhnSQL.prepare("""
    SELECT id from rhnServer
    WHERE digital_server_id=:did
    """)
    query_results = cursor.execute(did=('SALT-ID-%s' % minion))
    if query_results > 0:
        result = cursor.fetchone_dict()['id']
    return result


def create_actions_for_job(event):
    """
    TODO: doc
    """
    jid = event['data']['jid']
    minions = event['data']['minions']
    fun = event['data']['fun']

    with transaction(event):
        aid = rhnAction.schedule_action(action_type='salt.job',
                                        action_name='Salt job %s (%s)' %
                                        (jid, fun), org_id=1)
        cursor = rhnSQL.prepare("""
        insert into
        rhnActionSaltJob (action_id, jid, data)
        values (:action_id, :jid, :data)
        """)
        cursor.execute(action_id=aid, jid=jid,
                       data=json.dumps(event['data']))
        for minion in minions:
            sid = is_minion_registered(minion)
            if not sid:
                logger.warn("Skipping reference to unregistered minion: %s",
                            minion)
                continue
            cursor = rhnSQL.prepare("""
            insert into
            rhnServerAction (server_id, action_id, status, pickup_time)
            values (:server_id, :action_id, 0, :pickup_time)
            """)
            cursor.execute(server_id=sid, action_id=aid,
                           pickup_time=event['data']['_stamp'])


def update_actions_for_job(event):
    """
    Takes an function return event and sets the
    status of the corresponding Spacewalk job.
    """
    jid = event['data']['jid']
    minion = event['data']['id']

    sid = is_minion_registered(minion)
    if not sid > 0:
        logger.error('minion %s is not registered anymore', minion)
        # FIXME: cleanup its actions?
        return

    logger.info('Updating job status for sid %s: (%s) jid: %s',
                sid, minion, jid)

    with transaction(event):
        cursor = rhnSQL.prepare("""
        update rhnServerAction set
        status=:status,
        result_msg=:result_msg,
        result_code=:result_code,
        completion_time=:completion_time
        where action_id in
           (select distinct action_id from rhnActionSaltJob where jid=:jid)
        and server_id=:sid""")

        status = 2 if event['data']['success'] else 1
        cursor.execute(sid=sid,
                       status=status,
                       result_code=event['data']['retcode'],
                       result_msg=json.dumps(event['data']['return'])[:1024],
                       completion_time=event['data']['_stamp'],
                       jid=jid)


def request_minion_info(client, minion, cmd, desc):
    """
    Returns jobid for async cmd that was dispatched, False otherwise
    """
    jobid = client.cmd_async(minion, cmd)
    if jobid != 0:
        logger.info("Requested p %s for %s (jid %s)",
                    desc, minion, jobid)
        return jobid
    else:
        logger.warn("Request p %s failed for %s",
                    desc, minion)
        return False


def request_package_list(client, minion):
    """
    Returns the jobid for an async request for the minions
    package list, False otherwise
    """
    return request_minion_info(client, minion, 'pkg.list_pkgs', 'package list')


def request_network_ifaces(client, minion):
    """
    Returns the jobid for an async request for the minions
    network interface information, False otherwise
    """
    return request_minion_info(client, minion, 'network.interfaces',
                               'network interfaces')


def process_network_ifaces_result(minion, event):
    """
    TODO: doc
    """
    sid = is_minion_registered(minion)
    if not sid:
        return
    logger.info('Got network interfaces for %s', sid)
    ret = event['data']['return']
    profile = dict()

    profile['class'] = 'NETINTERFACES'
    for iface, details in ret.iteritems():
        profile[iface] = dict()
        profile[iface]['ipv6'] = list()
        profile[iface]['hwaddr'] = details['hwaddr']
        # FIXME: how to get the iface module with Salt?
        profile[iface]['module'] = 'Unknown'

        # only one ipv4 addr supported (TODO: upstream constraint?)
        for ipv4net in details['inet']:
            profile[iface]['ipaddr'] = ipv4net['address']
            profile[iface]['netmask'] = ipv4net['netmask']
            profile[iface]['broadcast'] = ipv4net['broadcast']
            break

        for ipv6net in details['inet6']:
            ipv6net['scope'] = 'Unknown'
            ipv6net['addr'] = ipv6net['address']
            ipv6net['netmask'] = ipv6net['prefixlen']
            profile[iface]['ipv6'].append(ipv6net)

        server = rhnServer.search(int(sid))

        # No need to delete the hardware as the class seems to ovewrite
        # the previous value
        server.add_hardware(profile)
        server.save_hardware()


def process_package_list_result(minion, event):
    """
    TODO: doc
    """
    logger.info('Got package list for %s', minion)

    package_list = event['data']['return']

    sid = is_minion_registered(minion)

    if sid:
        logger.info('Updating package list for Spacewalk sid=%s', sid)
        server = rhnServer.search(int(sid))
        server.dispose_packages()
        for package in package_list:
            server.add_package(package)
        server.save_packages()


def process_result(event):
    """
    TODO: doc
    """
    if 'data' in event and 'id' in event['data']:
        minion = event['data']['id']
        fun = event['data']['fun']

        if fun == 'pkg.list_packages':
            if event['data']['success']:
                process_package_list_result(minion, event)
            else:
                # TODO: actually log something
                logger.warn("")
        elif fun == 'network.interfaces':
            process_network_ifaces_result(minion, event)
        else:
            logger.warning('No handler for: %s', event)
    else:
        logger.warning('Cant process %s', event)


def main():
    """
    Entry point to the Spacewalk reactor
    """
    result = 0

    logger.info("###############################")
    logger.info("# Starting Spacewalk reactor. #")
    logger.info("###############################\n")

    initCFG()
    rhnSQL.initDB()

    pending_jobs = set()

    # TODO: is this needed?
    # In the original this was only referred to in the constructor.
    rpc = rpclib.Server(XMLRPC_URL)

    event_source = salt.utils.event.MasterEvent('/var/run/salt/master')
    client = salt.client.LocalClient()

    # TODO: InterruptException for a clean exit
    logger.info("Entering event loop.")
    for event in event_source.iter_events(full=True):
        # other possible values:
        # salt/key act accept, act reject
        # salt/auth
        if event['tag'] == 'salt/auth':
            minion = event['data']['id']
            logger.info("minion %s authenticated", minion)
            # TODO: do we need to do something?

        elif event['tag'] == 'minion_start':
            minion = event['data']['id']
            logger.info('minion %s started', minion)
            if not is_minion_registered(minion):
                register_system(client, event)

            package_list_job_id = request_package_list(client, minion)
            if package_list_job_id:
                pending_jobs.add(package_list_job_id)

            network_ifaces_job_id = request_network_ifaces(client, minion)
            if network_ifaces_job_id:
                pending_jobs.add(network_ifaces_job_id)

        elif re.match(r'salt/job/\d+/new', event['tag']):
            # create spacewalk action if the job was not created
            # by this reactor
            jid = event['data']['jid']
            if jid not in pending_jobs:
                logger.info('Adding job %s to Spacewalk', jid)
                create_actions_for_job(event)

        elif re.match(r'salt/job/\d+/ret/\S+', event['tag']):
            # minion return values
            if jid in pending_jobs:
                logger.info("processing job result for %s", jid)
                pending_jobs.remove(jid)
                process_result(event)
            else:
                logger.warning('Job event %s not generated by us',
                               event['tag'])
                update_actions_for_job(event)
        else:
            logger.warning('Not handling event %s', event['tag'])

    return result


if __name__ == "__main__":
    sys.exit(main())
