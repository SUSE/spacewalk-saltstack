#!/usr/bin/env python
# Copyright (c) 2014 SUSE
#
# Licensed under the MIT license. See MIT-LICENSE for details.
#
#from spacewalk.common.rhnException import rhnFault
import logging
import sys

import salt.utils.event
import salt.client

from spacewalk.common import rhnFlags
from spacewalk.server import rhnUser, rhnServer, rhnSQL
from spacewalk.common.rhnConfig import CFG, initCFG
from rhn import rpclib

initCFG()
rhnSQL.initDB()
logging.getLogger().addHandler(logging.StreamHandler())

def register_system(data):
    local = salt.client.LocalClient()
    minion = data['data']['id']

    # ask for the minion data to get its id that tell us
    # if it is registered, and data to register it
    ret = local.cmd_iter(minion, 'grains.items')

    for grains in ret:
        print(grains)

        if grains.has_key(minion):

            values = grains[minion]['ret']

            # cheat
            user = rhnUser.search('admin')

            rhnSQL.clear_log_id()
            newserv = rhnServer.Server(user, values['osarch'])

            # Idea. In the future, search for the reg key using
            # pillars. Then if no key is found for a system
            # use
            # tokens_obj = rhnServer.search_org_token(user.contact["org_id"])
            # rhnFlags.set("universal_registration_token", tokens_obj)
            #
            # XXX Hackweek hardcoded!
            tokens_obj = rhnServer.search_token('1-SALT')

            #log_user_id = tokens_obj.get_user_id()
            rhnFlags.set("registration_token", tokens_obj)

            # Use a generated spacewalk id for now
            #newserv.server.data['id'] = (234234234, 0)
            # reserve the id
            newserv.getid()
            # overrite the digital id
            newserv.server['digital_server_id'] =  'SALT-ID-%s' % minion
            newserv.server['release'] = values['osrelease']
            newserv.server['os'] = values['osfullname']
            newserv.server['name'] = minion
            newserv.server['running_kernel'] = values['kernelrelease']
            newserv.virt_uuid = None
            newserv.save()

            rhnSQL.commit()

            logging.info("%s registered as %s" % (minion, newserv.getid()))
        else:
            logging.warning("Can't get grains for %s" % minion)


class Saltwalk:

    def __init__(self):
        self.event_src = salt.utils.event.MasterEvent('/var/run/salt/master')
        self.pending_jobs = set()
        self.local = salt.client.LocalClient()

        XMLRPC_URL = "http://localhost/XMLRPC"
        self.rpc = rpclib.Server(XMLRPC_URL)

    def run(self):
        for ev in self.event_src.iter_events(full=True):
            # other possible values:
            # salt/key act accept, act reject
            # salt/auth
            if ev['tag'] == 'salt/auth':
                minion = ev['data']['id']
                logging.info("minion %s authenticated" % minion)
                # XXX do we need to do something?
            elif ev['tag'] == 'minion_start':
                minion = ev['data']['id']
                logging.info('minion %s started' % minion)
                if not self._is_registered(minion):
                    register_system(ev)
                self._request_package_list(minion)
                self._request_network_ifaces(minion)
            elif ev['tag'] == 'new_job':
                # XXX create spacewalk action?
                pass
            else:
                # only react to return values
                if (ev['data'].has_key('jid') and
                    ev['data'].has_key('cmd') and
                    ev['data']['cmd'] == '_return'):
                    jid = ev['data']['jid']
                    if jid in self.pending_jobs:
                        self._process_result(jid, ev)
                    else:
                        logging.warning('Job event %s not generated by us' % ev['tag'])
                else:
                    logging.warning('Not handling event %s' % ev['tag'])

    def _is_registered(self, minion):
        """Returns sid if a minion is registered, False otherwise"""
        query = rhnSQL.prepare('SELECT id from rhnServer WHERE digital_server_id=:did')
        result = query.execute(did=('SALT-ID-%s' % minion))

        if result > 0:
            return query.fetchone_dict()['id']
        return False

    def _request_minion_info(self, minion, cmd, desc):
        jobid = self.local.cmd_async(minion, cmd)
        if jobid != 0:
            logging.info("requested p %s for %s (jid %s)" % (desc, minion, jobid))
            self.pending_jobs.add(jobid)

    def _request_package_list(self, minion):
        self._request_minion_info(minion, 'pkg.list_pkgs', 'package list')

    def _request_network_ifaces(self, minion):
        self._request_minion_info(minion, 'network.interfaces', 'network interfaces')

    def _process_result(self, jid, ev):
        if ev.has_key('data') and ev['data'].has_key('id'):
            minion = ev['data']['id']

            fun = ev['data']['fun']
            if fun == 'pkg.list_packages':
                self._process_package_list_result(minion, ev)
            elif fun == 'network.interfaces':
                self._process_network_ifaces_result(minion, ev)
            else:
                logging.warning('No handler for: %s' % ev)
        else:
            logging.warning('Cant process %s' % ev)
        self.pending_jobs.remove(jid)

    def _process_network_ifaces_result(self, minion, ev):
        sid = self._is_registered(minion)
        logging.info('Got network interfaces for %s' % sid)
        if not sid:
            return
        ret = ev['data']['return']
        profile = dict()

        profile['class'] = 'NETINTERFACES'
        for iface, details in ret.iteritems():
            profile[iface] = dict()
            profile[iface]['ipv6'] = list()
            profile[iface]['hwaddr'] = details['hwaddr']
            # XXX how to get the iface module with Salt?
            profile[iface]['module'] = 'Unknown'

            # only one ipv4 addr supported
            for ipv4net in  details['inet']:
                profile[iface]['ipaddr'] = ipv4net['address']
                profile[iface]['netmask'] = ipv4net['netmask']
                profile[iface]['broadcast'] = ipv4net['broadcast']
                break

            for ipv6net in  details['inet6']:
                ipv6net['scope'] = 'Unknown'
                ipv6net['addr'] = ipv6net['address']
                ipv6net['netmask'] = ipv6net['prefixlen']
                profile[iface]['ipv6'].append(ipv6net)

        server = rhnServer.search(int(sid))
        # No need to delete the hardware as the class seems to ovewrite
        # the previous value
        server.add_hardware(profile)
        server.save_hardware()

    def _process_package_list_result(self, minion, ev):
        logging.info('Got package list for %s' % minion)
        if not ev['data']['success']:
            return

        package_list = ev['data']['return']
        # Use xml-rpc for now to upload the packages
        sid = self._is_registered(minion)
        logging.info('Updating package list for Spacewalk sid=%s' % sid)
        if sid:
            packages = [{'name': 'zlib', 'epoch': '', 'version': '1.2.7', 'release': '0.10.128', 'arch': 'x86_64', 'installtime': 1413297811}]
            server = rhnServer.search(int(sid))
            server.dispose_packages()
            for package in packages:
                server.add_package(package)
            server.save_packages()

kernel = Saltwalk()
kernel.run()
